#!/usr/bin/env python3
# release.py - Script de Release Autom√°tico em Python (Vers√£o Windows Corrigida)
import subprocess
import sys
import os
import re
from datetime import datetime

def run_command(cmd, check=True, capture_output=True):
    """Executa comando e retorna resultado"""
    try:
        result = subprocess.run(cmd, shell=True, check=check, 
                              capture_output=capture_output, text=True)
        return result.stdout.strip() if capture_output else None
    except subprocess.CalledProcessError as e:
        if check:
            print(f"‚ùå Erro executando: {cmd}")
            if capture_output and e.stderr:
                print(f"Erro: {e.stderr}")
            sys.exit(1)
        return None

def print_colored(text, color="white"):
    """Simula cores no terminal"""
    colors = {
        "red": "‚ùå", "green": "‚úÖ", "yellow": "‚ö†Ô∏è",
        "blue": "üîó", "cyan": "üîß", "white": ""
    }
    icon = colors.get(color, "")
    print(f"{icon} {text}")

def check_git():
    """Verifica se Git est√° dispon√≠vel"""
    git_commands = ["git", "git.exe"]
    for cmd in git_commands:
        try:
            subprocess.run([cmd, "--version"], check=True, 
                         capture_output=True, text=True)
            return cmd
        except (subprocess.CalledProcessError, FileNotFoundError):
            continue
    return None

def main():
    print("üîß Sistema de Release Autom√°tico HB Tracker")
    print("=" * 44)
    
    # Verifica√ß√£o de depend√™ncias
    print_colored("Verificando depend√™ncias...", "yellow")
    
    # Python j√° est√° funcionando (script est√° rodando)
    print_colored("Python encontrado e funcionando", "green")
    
    # Verifica Git
    git_cmd = check_git()
    if not git_cmd:
        print_colored("Git n√£o encontrado. Instale o Git primeiro.", "red")
        print("üí° Baixe em: https://git-scm.com/download/win")
        sys.exit(1)
    
    print_colored(f"Git encontrado: {git_cmd}", "green")
    
    # Verifica se estamos em um reposit√≥rio Git
    if not os.path.exists(".git"):
        print_colored("Este diret√≥rio n√£o √© um reposit√≥rio Git.", "red")
        print("üí° Execute: git init ou clone um reposit√≥rio existente")
        sys.exit(1)
    
    # Detecta automaticamente a branch principal
    print_colored("Detectando branch principal...", "yellow")
    
    main_branch = ""
    try:
        origin_head = run_command(f"{git_cmd} symbolic-ref refs/remotes/origin/HEAD", check=False)
        if origin_head:
            main_branch = origin_head.replace("refs/remotes/origin/", "")
    except:
        pass
    
    if not main_branch:
        # Verifica manualmente
        try:
            run_command(f"{git_cmd} show-ref --verify --quiet refs/heads/master", check=False)
            if run_command(f"{git_cmd} rev-parse --verify master", check=False):
                main_branch = "master"
        except:
            pass
        
        if not main_branch:
            try:
                run_command(f"{git_cmd} show-ref --verify --quiet refs/heads/main", check=False)
                if run_command(f"{git_cmd} rev-parse --verify main", check=False):
                    main_branch = "main"
            except:
                pass
    
    if not main_branch:
        print_colored("N√£o foi poss√≠vel detectar a branch principal", "red")
        print("üí° Branches dispon√≠veis:")
        try:
            branches = run_command(f"{git_cmd} branch", check=False)
            print(branches)
        except:
            pass
        
        main_branch = input("Digite o nome da branch principal (master/main): ").strip()
        if not main_branch:
            sys.exit(1)
    
    print_colored(f"Branch principal detectada: {main_branch}", "green")
    
    # Verifica se estamos na branch correta
    try:
        current_branch = run_command(f"{git_cmd} branch --show-current")
    except:
        current_branch = run_command(f"{git_cmd} rev-parse --abbrev-ref HEAD")
    
    if current_branch != main_branch:
        print_colored(f"Voc√™ est√° na branch '{current_branch}', mas a branch principal √© '{main_branch}'", "yellow")
        response = input(f"Deseja mudar para {main_branch}? (s/N): ").strip().lower()
        
        if response == 's':
            run_command(f"{git_cmd} checkout {main_branch}")
            print_colored(f"Mudou para a branch {main_branch}", "green")
        else:
            print_colored(f"Opera√ß√£o cancelada. Mude para a branch {main_branch} manualmente.", "red")
            sys.exit(1)
    
    # Verifica se h√° mudan√ßas n√£o commitadas
    status = run_command(f"{git_cmd} status --porcelain")
    if status:
        print_colored("H√° mudan√ßas n√£o commitadas no reposit√≥rio:", "yellow")
        run_command(f"{git_cmd} status --short", capture_output=False)
        print()
        response = input("Deseja continuar mesmo assim? (s/N): ").strip().lower()
        
        if response != 's':
            print_colored("Commit suas mudan√ßas antes de fazer o release.", "red")
            sys.exit(1)
    
    # Verifica conectividade com remote
    print_colored("Verificando conectividade com reposit√≥rio remoto...", "yellow")
    try:
        run_command(f"{git_cmd} ls-remote origin", check=False)
        print_colored("Conex√£o com reposit√≥rio remoto OK", "green")
    except:
        print_colored("Aviso: Problema de conectividade com reposit√≥rio remoto", "yellow")
        response = input("Deseja continuar mesmo assim? (s/N): ").strip().lower()
        if response != 's':
            sys.exit(1)
    
    # Puxa as √∫ltimas mudan√ßas
    print_colored("Sincronizando com o reposit√≥rio remoto...", "yellow")
    try:
        run_command(f"{git_cmd} fetch origin")
        run_command(f"{git_cmd} pull origin {main_branch}")
        print_colored("Sincroniza√ß√£o conclu√≠da", "green")
    except:
        print_colored("Aviso: N√£o foi poss√≠vel sincronizar completamente", "yellow")
    
    # L√™ vers√£o atual
    if not os.path.exists("version.py"):
        print_colored("Arquivo version.py n√£o encontrado.", "red")
        print("üí° Certifique-se de estar no diret√≥rio correto do projeto")
        sys.exit(1)
    
    try:
        # Adiciona o diret√≥rio atual ao path
        sys.path.insert(0, os.getcwd())
        
        # Remove o m√≥dulo se j√° estiver carregado
        if 'version' in sys.modules:
            del sys.modules['version']
            
        from version import Version
        current_version = Version.get_app_info()['version']
    except Exception as e:
        print_colored(f"Erro ao ler version.py: {e}", "red")
        current_version = "0.0.1"
        print_colored(f"Usando vers√£o padr√£o: {current_version}", "yellow")
    
    print(f"üìã Vers√£o atual: {current_version}")
    
    # Calcula nova vers√£o (incrementa patch)
    version_parts = current_version.split('.')
    try:
        major = int(version_parts[0])
        minor = int(version_parts[1]) if len(version_parts) > 1 else 0
        patch = int(version_parts[2]) if len(version_parts) > 2 else 0
    except:
        major, minor, patch = 0, 0, 1
    
    # Incrementa patch
    patch += 1
    new_version = f"{major}.{minor}.{patch}"
    
    print(f"üÜï Nova vers√£o: {new_version}")
    print()
    response = input("Confirma cria√ß√£o do release autom√°tico? (s/N): ").strip().lower()
    
    if response != 's':
        print_colored("Release cancelado.", "red")
        sys.exit(1)
    
    print(f"üöÄ Criando release autom√°tico para v{new_version}")
    
    # Atualiza version.py
    print(f"üìù version.py: {current_version} ‚Üí {new_version}")
    
    try:
        # L√™ o arquivo
        with open('version.py', 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Atualiza vers√£o
        content = re.sub(r'"version": "[^"]+"', f'"version": "{new_version}"', content)
        
        # Atualiza data de build
        current_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        content = re.sub(r'"build_date": "[^"]+"', f'"build_date": "{current_date}"', content)
        
        # Salva o arquivo
        with open('version.py', 'w', encoding='utf-8') as f:
            f.write(content)
        
        print_colored("version.py atualizado com sucesso", "green")
        
    except Exception as e:
        print_colored(f"Erro ao atualizar version.py: {e}", "red")
        sys.exit(1)
    
    # Verifica se a atualiza√ß√£o funcionou
    try:
        # Remove o m√≥dulo se j√° estiver carregado
        if 'version' in sys.modules:
            del sys.modules['version']
            
        from version import Version
        updated_version = Version.get_app_info()['version']
        
        if updated_version != new_version:
            print_colored("Aviso: Vers√£o pode n√£o ter sido atualizada corretamente", "yellow")
            print(f"Esperado: {new_version}, Encontrado: {updated_version}")
        
    except Exception as e:
        print_colored(f"Aviso: N√£o foi poss√≠vel verificar a atualiza√ß√£o: {e}", "yellow")
    
    # Commit das mudan√ßas
    print_colored("Fazendo commit das mudan√ßas...", "yellow")
    try:
        run_command(f"{git_cmd} add version.py")
        
        commit_message = f"üîñ Prepare release v{new_version}\n\n- Version bump: {current_version} ‚Üí {new_version}\n- Updated build timestamp\n- Ready for automated release"
        
        # Escapa as aspas para Windows
        commit_message_escaped = commit_message.replace('"', '\\"')
        run_command(f'{git_cmd} commit -m "{commit_message_escaped}"')
        
        print_colored("Commit realizado com sucesso", "green")
        
    except Exception as e:
        print_colored(f"Erro no commit: {e}", "red")
        sys.exit(1)
    
    # Cria tag
    print_colored("Criando tag...", "yellow")
    try:
        tag_message = f"Release v{new_version}\n\nüöÄ Release Autom√°tico\nüìÖ {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\nüîß Sistema HB Tracker\n\nFuncionalidades:\n- ‚úÖ Controle de invent√°rio inicial\n- ‚úÖ Monitoramento de movimentos\n- ‚úÖ Fluxo visual aprimorado\n- ‚úÖ Relat√≥rios export√°veis\n- ‚úÖ Sistema de atualiza√ß√µes autom√°ticas"
        
        tag_message_escaped = tag_message.replace('"', '\\"')
        run_command(f'{git_cmd} tag -a "v{new_version}" -m "{tag_message_escaped}"')
        
        print_colored(f"Tag v{new_version} criada localmente", "green")
        
    except Exception as e:
        print_colored(f"Erro ao criar tag: {e}", "red")
        sys.exit(1)
    
    # Push com a branch correta
    print_colored("Fazendo push da tag (isso vai disparar o GitHub Action)...", "yellow")
    
    try:
        print("üîÑ Pushing branch...")
        run_command(f"{git_cmd} push origin {main_branch}")
        
        print("üîÑ Pushing tag...")
        run_command(f'{git_cmd} push origin "v{new_version}"')
        
        print_colored(f"Release v{new_version} enviado com sucesso!", "green")
        print()
        print_colored("SUCESSO! Release autom√°tico criado:", "green")
        print(f"   üì¶ Vers√£o: v{new_version}")
        print(f"   üåø Branch: {main_branch}")
        print(f"   üè∑Ô∏è  Tag: v{new_version}")
        print()
        print_colored("O GitHub Actions vai processar automaticamente:", "yellow")
        print("   1. ‚öôÔ∏è  Build da aplica√ß√£o")
        print("   2. üì¶ Empacotamento com PyInstaller")
        print("   3. üöÄ Cria√ß√£o do release no GitHub")
        print("   4. üìé Upload do execut√°vel")
        print()
        print_colored("üîó Acompanhe em: https://github.com/esc4n0rx/HBTrackerx/actions", "blue")
        
    except Exception as e:
        print_colored("Erro no push:", "red")
        print(f"Detalhes: {e}")
        print("Verifique:")
        print("   - Conectividade com o GitHub")
        print("   - Permiss√µes do reposit√≥rio")
        print(f"   - Se a branch {main_branch} existe no remoto")
        print("   - Se voc√™ est√° autenticado no Git")
        
        # Rollback local
        print_colored("Fazendo rollback das mudan√ßas locais...", "yellow")
        try:
            run_command(f"{git_cmd} reset --hard HEAD~1")
            run_command(f'{git_cmd} tag -d "v{new_version}"')
            print_colored("Rollback conclu√≠do", "yellow")
        except:
            print_colored("Erro no rollback - verifique manualmente", "red")
        
        print_colored("Algo deu errado!", "red")
        sys.exit(1)

if __name__ == "__main__":
    main()