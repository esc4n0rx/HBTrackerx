# version.py - VERS√ÉO CORRIGIDA PARA SISTEMA DE ATUALIZA√á√ïES
import os
import json
import requests
import subprocess
import sys
from datetime import datetime
from PyQt5.QtWidgets import QMessageBox, QProgressDialog
from PyQt5.QtCore import QThread, pyqtSignal, Qt
import zipfile
import tempfile
import shutil

class Version:
    """Classe para gerenciar vers√µes da aplica√ß√£o"""
    
    CURRENT_VERSION = "0.0.4"
    APP_NAME = "Sistema de Controle de Caixas"
    
    # **CORRE√á√ÉO: URLs corretas do GitHub**
    UPDATE_SERVER = "https://api.github.com/repos/esc4n0rx/HBTrackerx"
    VERSION_CHECK_URL = f"{UPDATE_SERVER}/releases/latest"
    
    @staticmethod
    def get_current_version():
        """Retorna a vers√£o atual da aplica√ß√£o"""
        return Version.CURRENT_VERSION
    
    @staticmethod
    def get_app_info():
        """Retorna informa√ß√µes da aplica√ß√£o"""
        return {
            "name": Version.APP_NAME,
            "version": Version.CURRENT_VERSION,
            "build_date": "2025-06-12 13:10:07",
            "description": "Sistema completo de controle de caixas com invent√°rio inicial, fluxo visual para CDs e Lojas, e atualiza√ß√µes autom√°ticas",
            "author": "Desenvolvedor Python",
            "license": "Propriet√°rio",
            "website": "https://github.com/esc4n0rx/HBTrackerx",
            "support_email": "suporte@exemplo.com"
        }

class UpdateChecker(QThread):
    """Thread para verificar atualiza√ß√µes em background - VERS√ÉO CORRIGIDA"""
    
    update_available = pyqtSignal(dict)
    update_error = pyqtSignal(str)
    no_updates = pyqtSignal()
    
    def __init__(self):
        super().__init__()
        
    def run(self):
        """Verifica se h√° atualiza√ß√µes dispon√≠veis - VERS√ÉO CORRIGIDA"""
        try:
            print(f"üîç Verificando atualiza√ß√µes no GitHub...")
            print(f"üîó URL: {Version.VERSION_CHECK_URL}")
            
            # **CORRE√á√ÉO CR√çTICA: Headers corretos para GitHub API**
            headers = {
                'Accept': 'application/vnd.github.v3+json',
                'User-Agent': 'HBTracker-UpdateChecker/1.0',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache'
            }
            
            # **CORRE√á√ÉO: Timeout maior e retry logic**
            session = requests.Session()
            session.headers.update(headers)
            
            for attempt in range(3):  # At√© 3 tentativas
                try:
                    print(f"üîÑ Tentativa {attempt + 1}/3...")
                    response = session.get(Version.VERSION_CHECK_URL, timeout=30)
                    print(f"üìä Status da resposta: {response.status_code}")
                    
                    if response.status_code == 403:
                        print("‚ö†Ô∏è Erro 403 - tentando contornar rate limit...")
                        import time
                        time.sleep(2)  # Espera 2 segundos
                        continue
                    
                    if response.status_code == 404:
                        self.update_error.emit("Reposit√≥rio n√£o encontrado ou n√£o h√° releases dispon√≠veis")
                        return
                    
                    response.raise_for_status()
                    break  # Sucesso, sai do loop
                    
                except requests.exceptions.Timeout:
                    if attempt == 2:  # √öltima tentativa
                        raise
                    print(f"‚è±Ô∏è Timeout na tentativa {attempt + 1}, tentando novamente...")
                    continue
                except requests.exceptions.RequestException as e:
                    if attempt == 2:  # √öltima tentativa
                        raise
                    print(f"‚ùå Erro na tentativa {attempt + 1}: {e}")
                    continue
            
            release_info = response.json()
            print(f"üì¶ Release encontrado: {release_info.get('tag_name', 'N/A')}")
            
            # **CORRE√á√ÉO: Extrai vers√£o do tag_name**
            server_version = release_info.get('tag_name', '').replace('v', '')
            # version.py - CONTINUA√á√ÉO DA CORRE√á√ÉO
            current_version = Version.get_current_version()
            
            print(f"üìä Vers√£o atual: {current_version}")
            print(f"üìä Vers√£o servidor: {server_version}")
            
            if self.is_newer_version(server_version, current_version):
                print("‚úÖ Nova vers√£o dispon√≠vel!")
                
                # **CORRE√á√ÉO: Monta informa√ß√µes da atualiza√ß√£o**
                update_info = {
                    "version": server_version,
                    "release_date": release_info.get('published_at', '').split('T')[0],
                    "changelog": release_info.get('body', 'Sem informa√ß√µes de changelog'),
                    "download_url": None,
                    "file_size": "N/A"
                }
                
                # **CORRE√á√ÉO CR√çTICA: Busca arquivo de download correto**
                assets = release_info.get('assets', [])
                print(f"üì¶ Assets encontrados: {len(assets)}")
                
                for asset in assets:
                    asset_name = asset.get('name', '')
                    print(f"  - {asset_name}")
                    
                    # **CORRE√á√ÉO: Aceita diferentes formatos**
                    if (asset_name.endswith('.zip') or asset_name.endswith('.exe')) and \
                       ('ControleEstoque' in asset_name or 'HBTracker' in asset_name):
                        update_info["download_url"] = asset.get('browser_download_url')
                        update_info["file_size"] = f"{asset.get('size', 0) / 1024 / 1024:.1f} MB"
                        print(f"‚úÖ Arquivo de download encontrado: {asset_name}")
                        break
                
                if not update_info["download_url"]:
                    # **CORRE√á√ÉO: Fallback para qualquer arquivo .zip/.exe**
                    for asset in assets:
                        asset_name = asset.get('name', '')
                        if asset_name.endswith('.zip') or asset_name.endswith('.exe'):
                            update_info["download_url"] = asset.get('browser_download_url')
                            update_info["file_size"] = f"{asset.get('size', 0) / 1024 / 1024:.1f} MB"
                            print(f"‚ö†Ô∏è Usando arquivo alternativo: {asset_name}")
                            break
                
                if not update_info["download_url"]:
                    self.update_error.emit("Nenhum arquivo de atualiza√ß√£o encontrado no release")
                    return
                
                self.update_available.emit(update_info)
            else:
                print("‚úÖ Aplica√ß√£o est√° atualizada")
                self.no_updates.emit()
                
        except requests.exceptions.Timeout:
            error_msg = "Timeout na conex√£o com GitHub. Verifique sua internet."
            print(f"‚ùå {error_msg}")
            self.update_error.emit(error_msg)
        except requests.exceptions.ConnectionError:
            error_msg = "Erro de conex√£o com GitHub. Verifique sua internet."
            print(f"‚ùå {error_msg}")
            self.update_error.emit(error_msg)
        except requests.exceptions.HTTPError as e:
            if "403" in str(e):
                error_msg = "GitHub rate limit atingido. Tente novamente em alguns minutos."
            else:
                error_msg = f"Erro HTTP: {str(e)}"
            print(f"‚ùå {error_msg}")
            self.update_error.emit(error_msg)
        except requests.exceptions.RequestException as e:
            error_msg = f"Erro na requisi√ß√£o: {str(e)}"
            print(f"‚ùå {error_msg}")
            self.update_error.emit(error_msg)
        except json.JSONDecodeError as e:
            error_msg = f"Erro ao processar resposta do GitHub: {str(e)}"
            print(f"‚ùå {error_msg}")
            self.update_error.emit(error_msg)
        except Exception as e:
            error_msg = f"Erro inesperado: {str(e)}"
            print(f"‚ùå {error_msg}")
            self.update_error.emit(error_msg)
    
    def is_newer_version(self, server_version, current_version):
        """CORRE√á√ÉO: Compara vers√µes corretamente"""
        try:
            # Remove 'v' se presente e normaliza
            server_clean = server_version.replace('v', '').strip()
            current_clean = current_version.replace('v', '').strip()
            
            print(f"üîç Comparando vers√µes: '{current_clean}' vs '{server_clean}'")
            
            # Divide em partes num√©ricas
            server_parts = [int(x) for x in server_clean.split('.')]
            current_parts = [int(x) for x in current_clean.split('.')]
            
            # Normaliza o tamanho das listas
            max_len = max(len(server_parts), len(current_parts))
            server_parts.extend([0] * (max_len - len(server_parts)))
            current_parts.extend([0] * (max_len - len(current_parts)))
            
            print(f"üîç Partes servidor: {server_parts}")
            print(f"üîç Partes atual: {current_parts}")
            
            is_newer = server_parts > current_parts
            print(f"üîç √â mais nova? {is_newer}")
            
            return is_newer
        except ValueError as e:
            print(f"‚ùå Erro na compara√ß√£o de vers√µes: {e}")
            return False

class UpdateDownloader(QThread):
    """Thread para baixar e instalar atualiza√ß√µes - VERS√ÉO CORRIGIDA"""
    
    download_progress = pyqtSignal(int)
    download_finished = pyqtSignal()
    download_error = pyqtSignal(str)
    installation_progress = pyqtSignal(str)
    installation_finished = pyqtSignal()
    
    def __init__(self, update_info):
        super().__init__()
        self.update_info = update_info
        
    def run(self):
        """Baixa e instala a atualiza√ß√£o - VERS√ÉO CORRIGIDA"""
        try:
            self.installation_progress.emit("üîÑ Iniciando download...")
            
            # URL do arquivo de atualiza√ß√£o
            download_url = self.update_info.get("download_url")
            if not download_url:
                raise Exception("URL de download n√£o encontrada")
            
            print(f"üì• Baixando de: {download_url}")
            
            # Cria diret√≥rio tempor√°rio
            temp_dir = tempfile.mkdtemp()
            file_extension = ".zip" if download_url.endswith('.zip') else ".exe"
            update_file = os.path.join(temp_dir, f"update{file_extension}")
            
            self.installation_progress.emit("üì• Baixando atualiza√ß√£o...")
            
            # **CORRE√á√ÉO CR√çTICA: Headers e configura√ß√£o melhorada**
            headers = {
                'User-Agent': 'HBTracker-Updater/1.0',
                'Accept': 'application/octet-stream, */*',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                'Cache-Control': 'no-cache'
            }
            
            # **CORRE√á√ÉO: Session com retry logic**
            session = requests.Session()
            session.headers.update(headers)
            
            for attempt in range(3):
                try:
                    print(f"üîÑ Tentativa de download {attempt + 1}/3...")
                    
                    # **CORRE√á√ÉO: Configura√ß√µes de timeout e stream**
                    response = session.get(
                        download_url, 
                        stream=True, 
                        timeout=(30, 300),  # Connect timeout: 30s, Read timeout: 5min
                        allow_redirects=True
                    )
                    
                    if response.status_code == 403:
                        print("‚ö†Ô∏è Erro 403 no download - tentando novamente...")
                        import time
                        time.sleep(5)  # Espera mais tempo
                        continue
                    
                    response.raise_for_status()
                    break  # Sucesso
                    
                except requests.exceptions.RequestException as e:
                    if attempt == 2:  # √öltima tentativa
                        raise
                    print(f"‚ùå Erro na tentativa {attempt + 1}: {e}")
                    import time
                    time.sleep(3)
                    continue
            
            # **CORRE√á√ÉO: Download com progress melhorado**
            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0
            
            print(f"üìä Tamanho total: {total_size} bytes")
            
            with open(update_file, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        
                        if total_size > 0:
                            progress = int((downloaded / total_size) * 100)
                            self.download_progress.emit(progress)
                        
                        # **CORRE√á√ÉO: Feedback visual durante download**
                        if downloaded % (1024 * 1024) == 0:  # A cada MB
                            mb_downloaded = downloaded / (1024 * 1024)
                            mb_total = total_size / (1024 * 1024) if total_size > 0 else 0
                            self.installation_progress.emit(f"üì• Baixando: {mb_downloaded:.1f}MB/{mb_total:.1f}MB")
            
            print(f"‚úÖ Download conclu√≠do: {downloaded} bytes")
            self.download_finished.emit()
            
            # **CORRE√á√ÉO: Verifica integridade do arquivo**
            if not os.path.exists(update_file) or os.path.getsize(update_file) == 0:
                raise Exception("Arquivo de atualiza√ß√£o n√£o foi baixado corretamente")
            
            file_size = os.path.getsize(update_file)
            print(f"üìä Arquivo baixado: {file_size} bytes")
            
            if file_size < 1024:  # Arquivo muito pequeno
                raise Exception("Arquivo de atualiza√ß√£o parece estar corrompido (muito pequeno)")
            
            # **CORRE√á√ÉO: Tratamento diferente para .zip e .exe**
            if file_extension == ".zip":
                self.installation_progress.emit("üì¶ Extraindo atualiza√ß√£o...")
                
                # Extrai atualiza√ß√£o
                extract_dir = os.path.join(temp_dir, "extracted")
                
                try:
                    with zipfile.ZipFile(update_file, 'r') as zip_ref:
                        zip_ref.extractall(extract_dir)
                except zipfile.BadZipFile:
                    raise Exception("Arquivo ZIP est√° corrompido")
                
                print(f"üì¶ Arquivos extra√≠dos em: {extract_dir}")
                
                self.installation_progress.emit("üîÑ Aplicando atualiza√ß√£o...")
                
                # Aplica atualiza√ß√£o
                self.apply_update(extract_dir)
                
            else:  # .exe
                self.installation_progress.emit("üîÑ Executando instalador...")
                
                # **CORRE√á√ÉO: Para .exe, simplesmente executa**
                try:
                    import subprocess
                    subprocess.run([update_file], check=True)
                except subprocess.CalledProcessError as e:
                    raise Exception(f"Falha ao executar instalador: {e}")
            
            self.installation_progress.emit("‚úÖ Atualiza√ß√£o conclu√≠da!")
            self.installation_finished.emit()
            
        except Exception as e:
            error_msg = f"Erro na atualiza√ß√£o: {str(e)}"
            print(f"‚ùå {error_msg}")
            self.download_error.emit(error_msg)
        finally:
            # Limpa arquivos tempor√°rios
            try:
                if 'temp_dir' in locals():
                    shutil.rmtree(temp_dir, ignore_errors=True)
                    print("üßπ Arquivos tempor√°rios limpos")
            except:
                pass
    
    def apply_update(self, source_dir):
        """Aplica a atualiza√ß√£o substituindo arquivos - VERS√ÉO MELHORADA"""
        try:
            # **CORRE√á√ÉO: Detecta se √© execut√°vel compilado ou script Python**
            if getattr(sys, 'frozen', False):
                # Aplica√ß√£o compilada
                current_dir = os.path.dirname(sys.executable)
                current_executable = sys.executable
            else:
                # Script Python
                current_dir = os.path.dirname(os.path.abspath(__file__))
                current_executable = None
            
            print(f"üìÅ Diret√≥rio atual: {current_dir}")
            print(f"üìÅ Diret√≥rio fonte: {source_dir}")
            
            # **CORRE√á√ÉO: Lista arquivos para atualizar de forma mais inteligente**
            files_to_update = []
            
            for root, dirs, files in os.walk(source_dir):
                for file in files:
                    source_path = os.path.join(root, file)
                    rel_path = os.path.relpath(source_path, source_dir)
                    dest_path = os.path.join(current_dir, rel_path)
                    
                    # **CORRE√á√ÉO: Filtros mais espec√≠ficos**
                    if (file.endswith(('.exe', '.py', '.dll', '.pyd')) or 
                        file in ['version.json', 'config.ini'] or
                        not '.' in file):  # Arquivos sem extens√£o podem ser execut√°veis Unix
                        files_to_update.append((source_path, dest_path))
            
            print(f"üìã Arquivos para atualizar: {len(files_to_update)}")
            
            if not files_to_update:
                # **CORRE√á√ÉO: Se n√£o encontrou nada, tenta copiar tudo**
                print("‚ö†Ô∏è Nenhum arquivo espec√≠fico encontrado, copiando tudo...")
                for root, dirs, files in os.walk(source_dir):
                    for file in files:
                        source_path = os.path.join(root, file)
                        rel_path = os.path.relpath(source_path, source_dir)
                        dest_path = os.path.join(current_dir, rel_path)
                        files_to_update.append((source_path, dest_path))
            
            if not files_to_update:
                raise Exception("Nenhum arquivo encontrado para atualiza√ß√£o")
            
            # **CORRE√á√ÉO: Cria backup melhor**
            backup_dir = os.path.join(current_dir, f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
            os.makedirs(backup_dir, exist_ok=True)
            print(f"üìã Pasta de backup: {backup_dir}")
            
            # **CORRE√á√ÉO: Atualiza arquivos com melhor tratamento de erros**
            updated_count = 0
            for source_path, dest_path in files_to_update:
                try:
                    # **CORRE√á√ÉO: N√£o sobrescreve execut√°vel em uso**
                    if current_executable and os.path.samefile(dest_path, current_executable):
                        print(f"‚ö†Ô∏è Pulando execut√°vel em uso: {dest_path}")
                        continue
                    
                    # Backup do arquivo original se existir
                    if os.path.exists(dest_path):
                        backup_path = os.path.join(backup_dir, os.path.relpath(dest_path, current_dir))
                        os.makedirs(os.path.dirname(backup_path), exist_ok=True)
                        shutil.copy2(dest_path, backup_path)
                        print(f"üìã Backup: {os.path.basename(dest_path)}")
                    
                    # Copia novo arquivo
                    os.makedirs(os.path.dirname(dest_path), exist_ok=True)
                    shutil.copy2(source_path, dest_path)
                    print(f"‚úÖ Atualizado: {os.path.basename(dest_path)}")
                    updated_count += 1
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro ao atualizar {os.path.basename(dest_path)}: {e}")
                    # Continua com outros arquivos
            
            print(f"‚úÖ {updated_count} arquivos atualizados com sucesso")
            
            if updated_count == 0:
                raise Exception("Nenhum arquivo foi atualizado")
                    
        except Exception as e:
            print(f"‚ùå Erro na aplica√ß√£o da atualiza√ß√£o: {e}")
            raise